<?php

namespace Storm\Drivers\Base\Object\Properties\Proxies;

use \Storm\Core\Object;

class Null__Proxy implements IProxy {
    use \Storm\Core\Helpers\Type;
    use EntityProxyFunctionality;
    
    
    public function __construct() {
        return call_user_func_array([$this, '__ConstructProxy'], func_get_args());
    }
}

class DevelopmentProxyGenerator extends ProxyGenerator {
    const ProxyTemplate = <<<'NOW'
<?php

/**
 * Proxy Class for <EntityClass> auto-generated by Storm.
 *                  --DO NOT MODIFY--
 */

namespace <Namespace>;

use <ProxyInterface> as IProxy;
use <ProxyFunctionality> as ProxyFunctionality;

class <ProxyName> extends <EntityClass> implements IProxy {
    use ProxyFunctionality;
    
    public function __construct() {
        return call_user_func_array([$this, '__ConstructProxy'], func_get_args());
    }

    <OveriddenMethods>
}

?>
NOW;
    
    const OverriddenMethodTemplate = <<<'NOW'
   
    <Modifiers> <Name> (<Parameters>) {
        $this->__Load();
        return parent::<Name>(<ParameterVariables>);
    }
NOW;
    private static $NullProxyReflection;
    private static $NullProxyProperties = [];
    private static $NullProxyMethods = [];

    public function __construct($ProxyNamespace, $ProxyCachePath) {
        if(!isset(self::$NullProxyReflection)) {
            self::$NullProxyReflection = new \ReflectionClass(Null__Proxy::GetType());
            foreach(self::$NullProxyReflection->getProperties() as $Property) {
                self::$NullProxyProperties[$Property->getName()] = $Property;
            }
            foreach(self::$NullProxyReflection->getMethods() as $Method) {
                self::$NullProxyMethods[$Method->getName()] = $Method;
            }
        }

        parent::__construct($ProxyNamespace, $ProxyCachePath);
    }
    
    public function GenerateProxies(Object\Domain $Domain, $EntityType, 
            array $AlreadyKnownRevivalDataArray,
            array $RevivalDataLoaderFunctions) {
        $EntityReflection = new \ReflectionClass($EntityType);
        $ProxyClassName = $this->GenerateProxyClassName($EntityReflection->getName());
        $FullProxyName = $this->GetProxyFullName($ProxyClassName);
        
        $Proxies = [];
        foreach($RevivalDataLoaderFunctions as $Key => $RevivalDataLoaderFunction) {
            $Proxies[] = $this->GenerateProxyInstance($Domain, $EntityReflection, $ProxyClassName, $FullProxyName, 
                    $AlreadyKnownRevivalDataArray[$Key],
                    $RevivalDataLoaderFunction);
        }
        
        return $Proxies;
    }

    public function GenerateProxy(Object\Domain $Domain, $EntityType, 
            Object\RevivalData $AlreadyKnownRevivalData,
            callable $RevivalDataLoaderFunction) {
        $EntityReflection = new \ReflectionClass($EntityType);
        $ProxyClassName = $this->GenerateProxyClassName($EntityReflection->getName());
        $FullProxyName = $this->GetProxyFullName($ProxyClassName);
        
        return $this->GenerateProxyInstance($Domain, $EntityReflection, $ProxyClassName, $FullProxyName, 
                $AlreadyKnownRevivalData, $RevivalDataLoaderFunction);
    }
    
    private function GenerateProxyInstance(Object\Domain $Domain, $EntityReflection, $ProxyClassName, $FullProxyName, 
            Object\RevivalData $AlreadyKnownRevivalData,
            callable $RevivalDataLoaderFunction) {
        if(class_exists($FullProxyName, false)) {
            return new $FullProxyName($Domain, $AlreadyKnownRevivalData, $RevivalDataLoaderFunction);
        }
        else {
            $ProxyFileName = $this->GenerateProxyFileName($ProxyClassName);
            
            $this->GenerateProxyClassFile($ProxyFileName, $ProxyClassName, $EntityReflection);
            
            require $ProxyFileName;
            return new $FullProxyName($Domain, $AlreadyKnownRevivalData, $RevivalDataLoaderFunction);
        }
    }
    
    private function GenerateProxyClassFile($ProxyFileName, $ProxyClassName, \ReflectionClass $EntityReflection) {
        $ProxyClassTemplate = $this->GenerateProxyFileTemplate($ProxyClassName, $EntityReflection);
        $this->GenerateProxyFile($ProxyFileName, $ProxyClassTemplate);
    }

    private function GenerateProxyFile($ProxyFileName, $Template) {
        $DirectoryPath = pathinfo($ProxyFileName, PATHINFO_DIRNAME);
        if (!file_exists($DirectoryPath)) {
            mkdir($DirectoryPath, 0777, true);
        }
        file_put_contents($ProxyFileName, $Template);
    }

    private function GenerateProxyFileTemplate($ProxyClassName, \ReflectionClass $EntityReflection) {
        $ProxyTemplate = self::ProxyTemplate;

        $EntityClass = '\\' . $EntityReflection->getName();
        
        $OverridenMethods = '';// $this->GenerateOverridingMethods($EntityReflection);
        
        $Replacements = [
                    '<ProxyInterface>' => IProxy::IProxyType,
                    '<ProxyFunctionality>' => __NAMESPACE__ . '\\EntityProxyFunctionality',
                    '<Namespace>' => $this->ProxyNamespace,
                    '<ProxyName>' => $ProxyClassName,
                    '<EntityClass>' => $EntityClass,
                    '<OveriddenMethods>' => $OverridenMethods,
                ];
        
        $ProxyTemplate = str_replace(array_keys($Replacements), $Replacements, $ProxyTemplate);

        return $ProxyTemplate;
    }
    
    private function GenerateOverridingMethods(\ReflectionClass $EntityReflection) {
        $OverridenMethods = [];
        foreach($EntityReflection->getMethods() as $Method) {
            if(isset(self::$NullProxyMethods[$Method->getName()])
                    || !$Method->isPublic()
                    || $Method->isStatic()
                    || $Method->isFinal())
                continue;
            else {
                $OverridenMethods[] = $this->GenerateOverridingMethodTemplate($Method);
            }
        }
        
        return implode(PHP_EOL, $OverridenMethods);
    }

    private function GenerateOverridingMethodTemplate(\ReflectionMethod $EntityMethod) {
        $MethodTemplate = self::OverriddenMethodTemplate;

        $Modifiers = \Reflection::getModifierNames($EntityMethod->getModifiers());
        $Modifiers[] = 'function';
        if($EntityMethod->returnsReference())
            $Modifiers[] = '&';
        $Modifiers = implode(' ', $Modifiers);

        $Name = $EntityMethod->getName();

        $Parameters = [];
        $ParameterVariables = [];
        foreach($EntityMethod->getParameters() as $Parameter) {
            $ParameterVariables[] = '$' . $Parameter->getName();
            $Parameters[] = $this->GenerateMethodParameter($Parameter);
        }
        $Parameters = implode(', ', $Parameters);
        $ParameterVariables = implode(', ', $ParameterVariables);

        $MethodTemplate = str_replace('<Modifiers>', $Modifiers, $MethodTemplate);
        $MethodTemplate = str_replace('<Name>', $Name, $MethodTemplate);
        $MethodTemplate = str_replace('<Parameters>', $Parameters, $MethodTemplate);
        $MethodTemplate = str_replace('<ParameterVariables>', $ParameterVariables, $MethodTemplate);

        return $MethodTemplate;
    }

    private function GenerateMethodParameter(\ReflectionParameter $MethodParameter) {
        $TypeHint = '';
        if($MethodParameter->isArray())
            $TypeHint = 'array';
        else if($MethodParameter->isCallable())
            $TypeHint = 'callable';
        else {
            if($MethodParameter->getClass() !== null)
                $TypeHint = '\\' . $MethodParameter->getClass()->getName();
        }
        $Reference = $MethodParameter->isPassedByReference() ? '&' : '';
        $VariableName = '$' . $MethodParameter->getName();
        $DefaultValue = '';
        if($MethodParameter->isDefaultValueAvailable()) {
            $DefaultValue .= '= '; 
            /**
             *  -- CANT USE DUE TO COMPATIBILITY WITH PHP 5.4 -- 
                if($MethodParameter->isDefaultValueConstant()) 
                    $DefaultValue .= '\\' . $MethodParameter->getDefaultValueConstantName();
                else
             */
                $DefaultValue .= var_export($MethodParameter->getDefaultValue(), true);
        }

        return implode(' ', array_filter([$TypeHint, $Reference, $VariableName, $DefaultValue]));
    }
}

?>